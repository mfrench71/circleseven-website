<!-- Comments Section -->
{% assign post_slug = page.slug | default: page.title | slugify %}

<section class="comments-section" id="comments" data-post-slug="{{ post_slug }}">
  <h3 class="comments-heading">
    Comments
    <span class="comments-count" id="comments-count" style="display:none;"></span>
  </h3>

  <!-- Existing Comments (loaded dynamically) -->
  <div id="comments-loading" class="comments-loading">
    <p>Loading comments...</p>
  </div>
  <div id="comments-list" class="comments-list" style="display:none;"></div>
  <p id="no-comments" class="no-comments" style="display:none;">No comments yet. Be the first to comment!</p>

  <!-- Comment Form -->
  <div class="comment-form-container">
    <h4>Leave a Comment</h4>
    <form id="comment-form" class="comment-form" data-post-slug="{{ post_slug }}">
      <div class="form-group">
        <label for="comment-name">Name <span class="required">*</span></label>
        <input
          type="text"
          id="comment-name"
          name="name"
          required
          minlength="2"
          maxlength="100"
          placeholder="Your name"
          autocomplete="name"
        >
      </div>

      <div class="form-group">
        <label for="comment-email">Email <span class="required">*</span></label>
        <input
          type="email"
          id="comment-email"
          name="email"
          required
          placeholder="your@email.com"
          autocomplete="email"
        >
        <small class="form-help">Email is used for Gravatar only and will not be published.</small>
      </div>

      <div class="form-group">
        <label for="comment-message">Comment <span class="required">*</span></label>
        <textarea
          id="comment-message"
          name="message"
          required
          minlength="10"
          maxlength="5000"
          rows="6"
          placeholder="Write your comment here..."
        ></textarea>
        <small class="form-help character-count">0 / 5000 characters</small>
      </div>

      <!-- Honeypot field - hidden from humans, filled by bots -->
      <div class="honeypot-field">
        <label for="comment-website">Website</label>
        <input
          type="text"
          id="comment-website"
          name="website"
          tabindex="-1"
          autocomplete="off"
          placeholder="Your website URL"
        >
      </div>

      <div class="form-actions">
        <button type="submit" class="btn btn-primary" id="comment-submit">
          Post Comment
        </button>
        <span class="form-status" id="comment-status"></span>
      </div>
    </form>
  </div>
</section>

<script>
(function() {
  const form = document.getElementById('comment-form');
  if (!form) return;

  const submitBtn = document.getElementById('comment-submit');
  const statusEl = document.getElementById('comment-status');
  const messageField = document.getElementById('comment-message');
  const charCount = document.querySelector('.character-count');

  // Make status element a live region for screen reader announcements
  statusEl.setAttribute('role', 'status');
  statusEl.setAttribute('aria-live', 'polite');
  statusEl.setAttribute('aria-atomic', 'true');

  // Form field error handling
  function showFieldError(field, message, shouldFocus = false) {
    const errorId = field.id + '-error';

    // Create error message if doesn't exist
    let errorEl = document.getElementById(errorId);
    if (!errorEl) {
      errorEl = document.createElement('span');
      errorEl.id = errorId;
      errorEl.className = 'field-error';
      errorEl.setAttribute('role', 'alert');
      field.parentElement.appendChild(errorEl);
    }

    errorEl.textContent = message;
    field.setAttribute('aria-invalid', 'true');
    field.setAttribute('aria-describedby', errorId);

    if (shouldFocus) {
      field.focus(); // Focus the first invalid field only
    }
  }

  function clearFieldError(field) {
    const errorId = field.id + '-error';
    const errorEl = document.getElementById(errorId);

    if (errorEl) {
      errorEl.remove();
    }

    field.setAttribute('aria-invalid', 'false');
    field.removeAttribute('aria-describedby');
  }

  // Character counter
  if (messageField && charCount) {
    messageField.addEventListener('input', function() {
      const count = this.value.length;
      charCount.textContent = `${count} / 5000 characters`;
      if (count > 4800) {
        charCount.style.color = '#e74c3c';
      } else {
        charCount.style.color = '#666';
      }
    });
  }

  // Form submission
  form.addEventListener('submit', async function(e) {
    e.preventDefault();

    const postSlug = form.dataset.postSlug;
    const formData = new FormData(form);

    // Clear previous errors
    const nameField = document.getElementById('comment-name');
    const emailField = document.getElementById('comment-email');
    const messageFieldElement = document.getElementById('comment-message');

    [nameField, emailField, messageFieldElement].forEach(clearFieldError);

    // Client-side validation
    let valid = true;
    let firstInvalidField = null;
    const name = formData.get('name');
    const email = formData.get('email');
    const message = formData.get('message');

    if (!name || name.trim().length < 2) {
      showFieldError(nameField, 'Name must be at least 2 characters');
      if (!firstInvalidField) firstInvalidField = nameField;
      valid = false;
    }

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      showFieldError(emailField, 'Please enter a valid email address');
      if (!firstInvalidField) firstInvalidField = emailField;
      valid = false;
    }

    if (!message || message.trim().length < 10) {
      showFieldError(messageFieldElement, 'Comment must be at least 10 characters');
      if (!firstInvalidField) firstInvalidField = messageFieldElement;
      valid = false;
    }

    if (!valid) {
      statusEl.textContent = 'Please fix the errors above';
      statusEl.className = 'form-status error';
      // Focus the first invalid field
      if (firstInvalidField) {
        firstInvalidField.focus();
      }
      return;
    }

    const data = {
      postSlug: postSlug,
      name: name,
      email: email,
      message: message,
      website: formData.get('website') || '' // Honeypot field
    };

    // Disable submit button
    submitBtn.disabled = true;
    submitBtn.textContent = 'Posting...';
    statusEl.textContent = '';
    statusEl.className = 'form-status loading';

    try {
      const response = await fetch('/.netlify/functions/comments-submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      });

      const result = await response.json();

      if (response.ok) {
        statusEl.textContent = '✓ Comment submitted! It will appear after moderation.';
        statusEl.className = 'form-status success';
        form.reset();
        if (charCount) {
          charCount.textContent = '0 / 5000 characters';
          charCount.style.color = '#666';
        }
      } else {
        throw new Error(result.message || 'Failed to submit comment');
      }
    } catch (error) {
      statusEl.textContent = '✗ ' + error.message;
      statusEl.className = 'form-status error';
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Post Comment';
    }
  });

  // Load comments dynamically from API
  async function loadComments() {
    const section = document.getElementById('comments');
    if (!section) return;

    const postSlug = section.dataset.postSlug;
    if (!postSlug) return;

    const loadingEl = document.getElementById('comments-loading');
    const listEl = document.getElementById('comments-list');
    const noCommentsEl = document.getElementById('no-comments');
    const countEl = document.getElementById('comments-count');

    try {
      const response = await fetch(`/.netlify/functions/comments-api?postSlug=${encodeURIComponent(postSlug)}`);

      if (!response.ok) {
        // In local development, Netlify Functions don't exist - silently show no comments
        if (response.status === 404 && window.location.hostname === 'localhost') {
          console.info('[Comments] API not available in local development');
          loadingEl.style.display = 'none';
          noCommentsEl.style.display = 'block';
          return;
        }
        throw new Error(`Failed to load comments: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const comments = data.comments || [];

      // Hide loading
      loadingEl.style.display = 'none';

      // Update count
      if (comments.length > 0) {
        countEl.textContent = `(${comments.length})`;
        countEl.style.display = 'inline';
      }

      if (comments.length === 0) {
        noCommentsEl.style.display = 'block';
      } else {
        listEl.style.display = 'block';
        renderComments(comments, listEl);
      }
    } catch (error) {
      console.error('[Comments] Failed to load comments:', error);
      loadingEl.style.display = 'none';
      loadingEl.innerHTML = '<p class="error">Failed to load comments. Please try again later.</p>';
      loadingEl.style.display = 'block';
    }
  }

  function renderComments(comments, container) {
    container.innerHTML = comments.map(comment => {
      const date = new Date(comment.date).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      const gravatarUrl = `https://www.gravatar.com/avatar/${comment.emailHash}?s=80&d=retro`;

      return `
        <div class="comment-item">
          <div class="comment-header">
            <img src="${gravatarUrl}" alt="${escapeHtml(comment.name)}" class="comment-avatar">
            <div class="comment-meta">
              <strong class="comment-author">${escapeHtml(comment.name)}</strong>
              <time class="comment-date">${date}</time>
            </div>
          </div>
          <div class="comment-body">
            ${escapeHtml(comment.message).replace(/\n/g, '<br>')}
          </div>
        </div>
      `;
    }).join('');
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Load comments on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadComments);
  } else {
    loadComments();
  }
})();
</script>
